<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Chess Game</title>
    <style>
        body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;  /* Ensure full screen height is used */
    margin: 0;
    background-color: #f4f4f4;
}

.board {
    display: grid;
    grid-template-columns: repeat(8, 1fr);  /* Use flexible fractional units */
    grid-template-rows: repeat(8, 1fr);
    gap: 2px;
    width: 100%;  /* Allow the width and height to be set by JavaScript */
    height: 100%;  /* Allow the height to be set by JavaScript */
}

.square {
    background-color: #b58863;
    width: 100%;  /* Make the square's size fully responsive */
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
}
.selected{
    border: 2px solid blue;
    background-color: aqua;
}
        .square:nth-child(16n-4) {
            background-color: #f0d9b5;
        }
        .square:nth-child(16n-2) {
            background-color: #f0d9b5;
        }
        .square:nth-child(16n) {
            background-color: #f0d9b5;
        }
        .square:nth-child(16n+1) {
            background-color: #f0d9b5;
        }
        .square:nth-child(16n-6) {
            background-color: #f0d9b5;
        }
        .square:nth-child(16n+3) {
            background-color: #f0d9b5;
        }
        .square:nth-child(16n+5) {
            background-color: #f0d9b5;
        }
        .square:nth-child(16n+7) {
            background-color: #f0d9b5;
        }
        img {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div class="board" id="chessboard"></div>

    <script>
let currentPlayer = 'white'
let selectedSquare = null;
let board = [];
let isInCheck = false;
let blockingMoves;
let allValidMovesVar = null;
let attackingPiecesforKing = null;
const chessPieces = {
    'K': 'chess-game/K.png',
    'Q': 'chess-game/Q.png',
    'R': 'chess-game/R.png',
    'B': 'chess-game/B.png',
    'N': 'chess-game/N.png',
    'P': 'chess-game/P.png',
    'k': 'chess-game/k1.png',
    'q': 'chess-game/q1.png',
    'r': 'chess-game/r1.png',
    'b': 'chess-game/b1.png',
    'n': 'chess-game/n1.png',
    'p': 'chess-game/M.png',
};

const initialPosition = [
    ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
    ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
    ['', '', '', '', '', '', '', ''],
    ['', '', '', '', '', '', '', ''],
    ['', '', '', '', '', '', '', ''],
    ['', '', '', '', '', '', '', ''],
    ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
    ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'],
];

const arrayFinalPos = [];

function switchPlayer() {
    sendFenVar = true;
    currentPlayer = (currentPlayer === 'white') ? 'black' : 'white';
    console.log('Current Player is now:', currentPlayer);
}
function isKingInCheck(board){
    let undercheck = false;
    let kingPosition = findKingPosition('white', board)

    for (const square of board) {
        //console.log(square)
        const piece = square.img; // Accessing the img property to get the piece representation
        if (piece && piece === piece.toLowerCase()) { 
            undercheck = canPieceAttackKing(piece, square.row, square.col, kingPosition, board);
            if (undercheck) {
                console.log('Piece', piece)
                return true; // The white king is in check
            }
        }
    }
    return false;
}
function highlightsquare(square1){
    square1.isSelected = true;
}
function removehighlight(square1){
    square1.isSelected = false;
}
function simulateSquareClick(square) {
    // Ensure the square has a valid element and the event listener is defined
    if (square.element) {
        // Create a new MouseEvent to simulate the click
        const event = new MouseEvent('click', {
            bubbles: true,
            cancelable: true,
            view: window
        });

        // Dispatch the click event on the square's element
        square.element.dispatchEvent(event);
    }
}

function canPieceAttackKing(piece, pieceRow, pieceCol, kingPosition, board) {
    const kingRow = kingPosition.row;
    const kingCol = kingPosition.col;
    switch (piece) {
        case 'q': // Queen
            return canRookAttack(pieceRow, pieceCol, kingRow, kingCol, board, kingPosition) ||
                   canBishopAttack(pieceRow, pieceCol, kingRow, kingCol, board, kingPosition);
        case 'r': // Rook
            return canRookAttack(pieceRow, pieceCol, kingRow, kingCol, board, kingPosition);
        case 'b': // Bishop
            return canBishopAttack(pieceRow, pieceCol, kingRow, kingCol, board, kingPosition);
        case 'n': // Knight
            return canKnightAttack(pieceRow, pieceCol, kingRow, kingCol);
        case 'p': // Pawn
            return canPawnAttack(piece, pieceRow, pieceCol, kingRow, kingCol);
        case 'k': // King
            return canKingAttack(pieceRow, pieceCol, kingRow, kingCol);
        default:
            return false;
    }
}



// Rook attack logic (can attack horizontally or vertically)
function canRookAttack(pieceRow, pieceCol, kingRow, kingCol, board, kingPosition) {
    if (pieceRow === kingRow || pieceCol === kingCol) {
        return isPathClearIgnoreKing(pieceRow, pieceCol, kingRow, kingCol, board, kingPosition);
    }
    return false;
}

// Bishop attack logic (can attack diagonally)
function canBishopAttack(pieceRow, pieceCol, kingRow, kingCol, board, kingPosition) {
    if (Math.abs(pieceRow - kingRow) === Math.abs(pieceCol - kingCol)) {
        return isPathClearIgnoreKing(pieceRow, pieceCol, kingRow, kingCol, board, kingPosition);
    }
    return false;
}


// Knight attack logic (L-shaped moves)
function canKnightAttack(pieceRow, pieceCol, kingRow, kingCol) {
    const rowDiff = Math.abs(pieceRow - kingRow);
    const colDiff = Math.abs(pieceCol - kingCol);
    return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
}

// Pawn attack logic (diagonal attack for black pawns)
function canPawnAttack(pawn, pieceRow, pieceCol, kingRow, kingCol) {
    return pawn === 'p' && pieceRow + 1 === kingRow && Math.abs(pieceCol - kingCol) === 1;
}



// King attack logic (can attack one square around)
function canKingAttack(pieceRow, pieceCol, kingRow, kingCol) {
    return Math.abs(pieceRow - kingRow) <= 1 && Math.abs(pieceCol - kingCol) <= 1;
}






function getBlockingMoves(board, currentPlayer) {
    let blockingMoves = [];
    
    let kingPosition = board.find(square => square.img === 'K');
    if (!kingPosition) {
        console.error('King not found on the board');
        return [];
    }

    // Get the pieces attacking the king
    let attackingPieces = getAttackingPieces(board, currentPlayer === 'white' ? 'black' : 'white'); // Opponent's pieces
    if (attackingPieces.length === 0) {
        return []; // No attackers, no need to block
    }

    // Loop through each attacking piece
    for (let attacker of attackingPieces) {
        // Check if the attacker is a knight (cannot be blocked, only captured or king must move)
        if (attacker.img === 'N' || attacker.img === 'n') {
            // Add moves where the attacker can be captured
            let captureMoves = getCaptureMoves(currentPlayer, attacker, board);
            blockingMoves = blockingMoves.concat(captureMoves);
        } else {
            // For Rook, Bishop, or Queen, check for blocking moves
            let lineOfAttack = getLineOfAttack(kingSquare, attacker, board);

            // For each piece of the current player, check if it can block the line of attack
            let playerPieces = getPlayerPieces(board, currentPlayer);
            
            for (let piece of playerPieces) {
                if (piece.img !== 'K' && piece.img !== 'P') { // Skip king and pawns for blocking
                    let allValidMoves = getAllValidMoves(piece, board);
                    
                    allValidMoves.forEach(move => {
                        if (lineOfAttack.includes(move)) {
                            blockingMoves.push(move); // Add move to block the line of attack
                        }
                    });

                    // Also check if this piece can capture the attacker directly
                    if (allValidMoves.includes(attacker.row * 8 + attacker.col)) {
                        blockingMoves.push(attacker.row * 8 + attacker.col); // Add capture move
                    }
                }
            }
        }
    }

    return blockingMoves;
}
function findKingPosition(currentPlayer, board) {
    // Define the king image based on the current player
    let kingImage = currentPlayer === 'white' ? 'K' : 'k';

    // Iterate through the board using row and column
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            let square = getSquareAt(row, col); // Get the square using getSquareAt
            
            // Check if the square contains the king
            if (square !== null && square.img === kingImage) {
                return { row, col };  // Return the king's position as {row, col}
            }
        }
    }

    return null; // Return null if the king is not found (should not happen in a valid game)
}



function getAttackingPieces(board, currentPlayer) {
    let attackingPieces = [];
    
    // Find the king's position for the current player
    let kingPosition = findKingPosition(currentPlayer, board);

    // Get opponent's pieces (black if currentPlayer is white, and vice versa)
    let opponentColor = currentPlayer === 'white' ? 'black' : 'white';
    let opponentPieces = getPlayerPieces(board, opponentColor);

    opponentPieces.forEach(piece => {
        let validMoves = getAllValidMoves(piece, board);
        
        // Check if the king's position is among the valid moves of this piece
        if (validMoves.includes(kingPosition)) {
            attackingPieces.push(piece); // This piece is attacking the king
        }
    });

    return attackingPieces;
}


function getPlayerPieces(board, playerColor) {
    let playerPieces = [];

    board.forEach(square => {
        if (square.img && square.img !== '') {
            // Check if the piece belongs to the specified player
            if ((playerColor === 'white' && square.img.toUpperCase() === square.img) || 
                (playerColor === 'black' && square.img.toLowerCase() === square.img)) {
                playerPieces.push(square); // Add the square with the player's piece
            }
        }
    });

    return playerPieces;
}
function getOppositeDirectionBetween(start, end) {
    // Calculate the direction from start to end
    let direction = getDirectionBetween(start, end);

    // Return the opposite direction
    return {
        rowDir: -direction.rowDir,
        colDir: -direction.colDir
    };
}


function getLineOfAttack(kingSquare, attacker, board) {
    let lineOfAttack = [];
    
    let kingRow = kingSquare.row;
    let kingCol = kingSquare.col;
    let attackerRow = attacker.row;
    let attackerCol = attacker.col;
    
    // Vertical attack
    if (kingCol === attackerCol) {
        let step = kingRow < attackerRow ? 1 : -1;
        for (let i = kingRow + step; i !== attackerRow; i += step) {
            lineOfAttack.push(i * 8 + kingCol); // Convert to flat index
        }
    }
    // Horizontal attack
    else if (kingRow === attackerRow) {
        let step = kingCol < attackerCol ? 1 : -1;
        for (let i = kingCol + step; i !== attackerCol; i += step) {
            lineOfAttack.push(kingRow * 8 + i); // Convert to flat index
        }
    }
    // Diagonal attack
    else if (Math.abs(kingRow - attackerRow) === Math.abs(kingCol - attackerCol)) {
        let rowStep = kingRow < attackerRow ? 1 : -1;
        let colStep = kingCol < attackerCol ? 1 : -1;
        let i = kingRow + rowStep;
        let j = kingCol + colStep;
        while (i !== attackerRow && j !== attackerCol) {
            lineOfAttack.push(i * 8 + j); // Convert to flat index
            i += rowStep;
            j += colStep;
        }
    }

    return lineOfAttack;
}



// Helper function to check if a piece can capture the attacking piece
function getCaptureMoves(currentPlayer, attacker) {
    let captureMoves = [];

    // Loop through all pieces of the current player
    let playerPieces = getPlayerPieces(board, 'white');

    for (let piece of playerPieces) {
        //allValidMovesVar = getAllValidMoves(piece, board);
        if (validMoves.includes(attacker.position)) {
            captureMoves.push(attacker.position); // This piece can capture the attacker
        }
    }

    return captureMoves;
}

// Helper function to get the direction between two positions (used to calculate line of attack)
function getDirectionBetween(start, end) {
    // Logic to determine the direction (vertical, horizontal, or diagonal)
    // For example, (1, 0) for vertical, (0, 1) for horizontal, (1, 1) for diagonal
    let rowDiff = end.row - start.row;
    let colDiff = end.col - start.col;

    return {
        rowDir: rowDiff === 0 ? 0 : rowDiff / Math.abs(rowDiff),
        colDir: colDiff === 0 ? 0 : colDiff / Math.abs(colDiff)
    };
}

// Helper function to move one step in a given direction
function moveOneStep(position, direction) {
    return {
        row: position.row + direction.rowDir,
        col: position.col + direction.colDir
    };
}

function getAllValidMoves(pieceSquare, board) {
    let allValidMovesVar = [];
    const piece = pieceSquare.img;
    const row = pieceSquare.row;
    const col = pieceSquare.col;

    switch (piece.toUpperCase()) {
        case 'P': // Pawn
        allValidMovesVar = getPawnMoves(pieceSquare, board);
            break;
        case 'R': // Rook
        allValidMovesVar = getRookMoves(pieceSquare, board);
            break;
        case 'N': // Knight
        allValidMovesVar = getKnightMoves(pieceSquare, board);
            break;
        case 'B': // Bishop
        allValidMovesVar = getBishopMoves(pieceSquare, board);
            break;
        case 'Q': // Queen
        allValidMovesVar = getQueenMoves(pieceSquare, board);
            break;
        case 'K': // King
        allValidMovesVar = getKingMoves(pieceSquare, board);

            break;
    }

    // Filter out moves that go off the board or capture friendly pieces
    allValidMovesVar = allValidMovesVar.filter(square => isValidDestination(pieceSquare, square, board));
    return allValidMovesVar;
}
function getKingMoves(pieceSquare, board) {
    let validMoves = [];
    const row = pieceSquare.row;
    const col = pieceSquare.col;
    const color = pieceSquare.img === pieceSquare.img.toUpperCase() ? 'w' : 'b';

    // King can move in 8 possible directions
    const kingMoves = [
        { rowOffset: -1, colOffset: 0 },  // Up
        { rowOffset: 1, colOffset: 0 },   // Down
        { rowOffset: 0, colOffset: -1 },  // Left
        { rowOffset: 0, colOffset: 1 },   // Right
        { rowOffset: -1, colOffset: -1 }, // Up-left
        { rowOffset: -1, colOffset: 1 },  // Up-right
        { rowOffset: 1, colOffset: -1 },  // Down-left
        { rowOffset: 1, colOffset: 1 }    // Down-right
    ];

    kingMoves.forEach(move => {
        const newRow = row + move.rowOffset;
        const newCol = col + move.colOffset;

        // Ensure the move is within bounds of the board
        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
            const targetSquare = board[newRow * 8 + newCol];

            // If the square is empty or occupied by an opponent piece, it's a valid move
            if (!targetSquare.img || (targetSquare.img.toUpperCase() !== pieceSquare.img.toUpperCase())) {
                validMoves.push(targetSquare); // Enemy piece, valid capture
            }
        }
    });
    return validMoves;
}




function getRookMoves(pieceSquare, board) {
    let moves = [];
    const row = pieceSquare.row;
    const col = pieceSquare.col;

    // Rook moves horizontally and vertically
    // Move up
    for (let r = row - 1; r >= 0; r--) {
        if (addMoveIfValid(r, col, pieceSquare, board, moves)) break;
    }
    // Move down
    for (let r = row + 1; r < 8; r++) {
        if (addMoveIfValid(r, col, pieceSquare, board, moves)) break;
    }
    // Move left
    for (let c = col - 1; c >= 0; c--) {
        if (addMoveIfValid(row, c, pieceSquare, board, moves)) break;
    }
    // Move right
    for (let c = col + 1; c < 8; c++) {
        if (addMoveIfValid(row, c, pieceSquare, board, moves)) break;
    }

    return moves;
}
function getKnightMoves(pieceSquare, board) {
    let moves = [];
    const row = pieceSquare.row;
    const col = pieceSquare.col;

    // Possible knight moves (L-shape)
    const knightMoves = [
        { r: -2, c: -1 }, { r: -2, c: 1 },
        { r: -1, c: -2 }, { r: -1, c: 2 },
        { r: 1, c: -2 },  { r: 1, c: 2 },
        { r: 2, c: -1 },  { r: 2, c: 1 }
    ];

    knightMoves.forEach(move => {
        const newRow = row + move.r;
        const newCol = col + move.c;
        if (isOnBoard(newRow, newCol)) {
            addMoveIfValid(newRow, newCol, pieceSquare, board, moves);
        }
    });

    return moves;
}
function getBishopMoves(pieceSquare, board) {
    let moves = [];
    const row = pieceSquare.row;
    const col = pieceSquare.col;

    // Bishop moves diagonally
    // Move top-left
    for (let r = row - 1, c = col - 1; r >= 0 && c >= 0; r--, c--) {
        if (addMoveIfValid(r, c, pieceSquare, board, moves)) break;
    }
    // Move top-right
    for (let r = row - 1, c = col + 1; r >= 0 && c < 8; r--, c++) {
        if (addMoveIfValid(r, c, pieceSquare, board, moves)) break;
    }
    // Move bottom-left
    for (let r = row + 1, c = col - 1; r < 8 && c >= 0; r++, c--) {
        if (addMoveIfValid(r, c, pieceSquare, board, moves)) break;
    }
    // Move bottom-right
    for (let r = row + 1, c = col + 1; r < 8 && c < 8; r++, c++) {
        if (addMoveIfValid(r, c, pieceSquare, board, moves)) break;
    }

    return moves;
}
function addMoveIfValid(row, col, pieceSquare, board, moves) {
    const targetSquare = getSquareAt(row, col);

    if (!targetSquare) return false; // Out of bounds check

    // Check if the target square contains a piece
    if (targetSquare.img === '') {
        moves.push(targetSquare); // Empty square, valid move
        return false; // Continue checking further squares
    } else if (isEnemyPiece(row, col, pieceSquare.img, board)) {
        moves.push(targetSquare); // Enemy piece, valid capture
        return true; // Stop checking further in this direction
    } else {
        return true; // Friendly piece, block movement
    }
}
function isOnBoard(row, col) {
    return row >= 0 && row < 8 && col >= 0 && col < 8;
}
function isEnemyPiece(row, col, piece, board) {
    const targetSquare = getSquareAt(row, col);
    if (!targetSquare || targetSquare.img === '') return false; // Empty square

    const pieceColor = piece === piece.toUpperCase() ? 'white' : 'black';
    const targetColor = targetSquare.img === targetSquare.img.toUpperCase() ? 'white' : 'black';

    return pieceColor !== targetColor; // True if the piece belongs to the opponent
}
function getQueenMoves(pieceSquare, board) {
    let moves = [];

    // Queen moves are a combination of rook and bishop moves
    moves = moves.concat(getRookMoves(pieceSquare, board));  // Horizontal and vertical moves
    moves = moves.concat(getBishopMoves(pieceSquare, board)); // Diagonal moves

    return moves;
}

function isValidDestination(fromSquare, toSquare, board) {
    // Ensure the target square is within the board and doesn't contain a friendly piece
    if (!toSquare || !toSquare.img) return true; // Empty square is valid
    const pieceColor = fromSquare.img === fromSquare.img.toUpperCase() ? 'white' : 'black';
    const targetColor = toSquare.img === toSquare.img.toUpperCase() ? 'white' : 'black';

    return pieceColor !== targetColor; // Valid if the destination square contains an enemy piece or is empty
}
function isEmptySquare(row, col, board) {
    // Check if the square is within the bounds of the board
    if (!isOnBoard(row, col)) {
        return false; // Not a valid square
    }
    return getSquareAt(row, col).img === ''; // Assuming empty square has an empty string for the img property
}

function getPawnMoves(pieceSquare, board) {
    let moves = [];
    const row = pieceSquare.row;
    const col = pieceSquare.col;
    const direction = pieceSquare.img === 'P' ? -1 : 1; // White moves up, black moves down

    // Normal move forward
    if (isEmptySquare(row + direction, col, board)) {
        moves.push(getSquareAt(row+direction, col));
    }

    // Capture diagonally
    if (isEnemyPiece(row + direction, col - 1, pieceSquare.img, board)) {
        moves.push(getSquareAt(row+direction, col-1));
    }
    if (isEnemyPiece(row + direction, col + 1, pieceSquare.img, board)) {
        moves.push(getSquareAt(row+direction, col+1));
    }

    // Pawn initial double move
    if ((pieceSquare.img === 'P' && row === 6) || (pieceSquare.img === 'p' && row === 1)) {
        if (isEmptySquare(row + 2 * direction, col, board)) {
            moves.push(getSquareAt(row+2*direction, col));
        }
    }

    return moves;
}


function createBoard() {
    const chessboard = document.getElementById('chessboard');
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const piece = initialPosition[row][col];  // Get piece from initialPosition
            const square = {
                img: piece,  // This stores the piece in this square
                row: row,
                col: col,
                captured: false,
                promoted: false,
                element: document.createElement('div'),
                hasMoved: false,
                isUnderAttack: false,  // Tracks if this square is under attack by any opponent piece
                attackingPieces: [],  // Array to store pieces currently attacking this square
                pieceColor: piece ? (piece === piece.toLowerCase() ? 'black' : 'white') : null, // Determine piece color
                isSelected: false,
            };

            // Set CSS class for square
            square.element.classList.add('square');

            // If there's a piece on this square, create an img element for it
            if (square.img) {
                const imgElement = document.createElement('img');
                imgElement.src = chessPieces[square.img];  // Use piece to map to the image
                square.element.appendChild(imgElement);
            }

            // Add the square to the board array
            board.push(square);

            // Append the square's element to the chessboard
            chessboard.appendChild(square.element);

            // Add a click event listener for selecting the square
            square.element.addEventListener('click', () => handleSquareClick(square));
        }
    }
}

// Helper function to disable all moves (removes click events or disables piece selection)
function disableAllMoves() {
    let allSquares = document.querySelectorAll('.square');  // Select all squares
    allSquares.forEach(square => {
        // Remove existing click listeners for move events
        let newSquare = square.cloneNode(true);
        square.parentNode.replaceChild(newSquare, square);  // This removes all event listeners
    });
}

let sendFenVar = true;
function handleSquareClick(square) {
    if (selectedSquare) {
        if (validMove(selectedSquare, square) && sendFenVar) {
            movePiece(selectedSquare, square);
            
            if ((selectedSquare.img === 'P' && square.row === 0) || (selectedSquare.img === 'p' && square.row === 7)) {
                promotePawn(square);
            }
            selectedSquare = null; // Reset selected square for the next move
            
            sendFenVar = sendFenToApi();
        } else {
            if (square.img === '') {
                // Deselect if the new square is empty
                console.log("Invalid move! Deselecting the piece.");
                selectedSquare = null; // Reset selected square
            } else if (square.img && square.img.toUpperCase() === square.img) {
                // Select the new piece if it's a valid white piece
                console.log("Invalid move! Selecting another piece.");
                selectedSquare = square; // Change the selected square to the new piece
            } else {
                console.log("Invalid move! Cannot move to a square occupied by a black piece.");
            }
        }
    } else if (square.img && square.img.toUpperCase() === square.img) {
        // Select square if it contains a white piece (uppercase)
        selectedSquare = square; // Set the selected square to the clicked square
    }
}

function validMove(fromSquare, toSquare) {
    const piece = fromSquare.img;
    const fromRow = fromSquare.row;
    const fromCol = fromSquare.col;
    const toRow = toSquare.row;
    const toCol = toSquare.col;

    const targetPiece = toSquare.img;
    //console.log(fromRow, fromCol)
    const isSameColor = targetPiece && targetPiece.toUpperCase() === targetPiece;
    // Prevent capturing own pieces
    if (isSameColor) {
        return false; // Cannot capture own piece
    }

    switch (piece) {
        case 'P': // White Pawn
            if (fromCol === toCol) {
                // Regular move forward
                if (fromRow - 1 === toRow && !toSquare.img) return true; // Move forward
                // Double move from starting position
                if (fromRow === 6 && fromRow - 2 === toRow && !toSquare.img) return true; // Double move from start
            } else if (Math.abs(fromCol - toCol) === 1 && fromRow - 1 === toRow) {
                // Capture move
                if (targetPiece && targetPiece.toLowerCase() === targetPiece) {
                    return true; // Capture a black piece
                }
            }
            break;
        case 'R': // Rook
            if (fromRow === toRow || fromCol === toCol) {
                return isPathClear(fromRow, fromCol, toRow, toCol);
            }
            break;
        case 'N': // Knight
            if ((Math.abs(fromRow - toRow) === 2 && Math.abs(fromCol - toCol) === 1) || (Math.abs(fromRow - toRow) === 1 && Math.abs(fromCol - toCol) === 2)) {
                return true; // L-shaped move
            }
            break;
        case 'B': // Bishop
            if (Math.abs(fromRow - toRow) === Math.abs(fromCol - toCol)) {
                return isPathClear(fromRow, fromCol, toRow, toCol);
            }
            break;
        case 'Q': // Queen
            if (fromRow === toRow || fromCol === toCol || Math.abs(fromRow - toRow) === Math.abs(fromCol - toCol)) {
                return isPathClear(fromRow, fromCol, toRow, toCol);
            }
            break;
        case 'K': // White King
            
            if (handleKingMove(fromRow, fromCol, toRow, toCol, board, isInCheck, piece, targetPiece)) {
                console.log("King move completed successfully.");
                return true;
            } else {
                console.log("King move failed.");
                return false;
            }     
            break;
    }
    
    return false;
}

function isKingSafe(kingRow, kingCol, board) {
    let checkingcheck = isKingInCheck(board);
    if(checkingcheck){
        console.log('move the king or block the check')
    }
    return !checkingcheck;
}
function hasKingMoved(){
    return false;
}


function getKingPossibleMoves(board, kingRow, kingCol) {
    // Array to store all possible moves for the king
    let possibleMoves = [];

    // Define the 8 possible directions the king can move
    const directions = [
        [-1, -1], [-1, 0], [-1, 1], // Top-left, Top, Top-right
        [0, -1],          [0, 1],   // Left,         Right
        [1, -1], [1, 0], [1, 1]    // Bottom-left, Bottom, Bottom-right
    ];

    // Iterate over all the directions
    directions.forEach(direction => {
        const newRow = kingRow + direction[0];
        const newCol = kingCol + direction[1];

        // Check if the new position is within the board boundaries
        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
            possibleMoves.push({ row: newRow, col: newCol });
        }
    });
    let kingPosition = findKingPosition('white', board)
    let updatedPossibleMoves = notBlocked(kingPosition.row, kingPosition.col, board, currentPlayer, possibleMoves);
    possibleMoves = updatedPossibleMoves;
    const castlingMoves = getCastlingMoves(kingPosition.row, kingPosition.col, board, isInCheck);
    possibleMoves.push(...castlingMoves);
    allValidMovesVar = possibleMoves;
    return possibleMoves;
}

function handleMove(kingPosition, board) {
    let possibleMoves = [];
    
    // Get king's current row and column
    const { row: kingRow, col: kingCol } = kingPosition;

    // Directions for Rook (horizontal & vertical), Bishop (diagonal), and Knight (L-shaped moves)
    const rookDirections = [
        { row: -1, col: 0 }, // Up
        { row: 1, col: 0 },  // Down
        { row: 0, col: -1 }, // Left
        { row: 0, col: 1 },  // Right
    ];

    const bishopDirections = [
        { row: -1, col: -1 }, // Top-left
        { row: -1, col: 1 },  // Top-right
        { row: 1, col: -1 },  // Bottom-left
        { row: 1, col: 1 }    // Bottom-right
    ];

    const knightMoves = [
        { row: -2, col: -1 }, { row: -2, col: 1 },
        { row: -1, col: -2 }, { row: -1, col: 2 },
        { row: 1, col: -2 },  { row: 1, col: 2 },
        { row: 2, col: -1 },  { row: 2, col: 1 }
    ];

    // Check Rook-like and Bishop-like movements (King attacks like a rook or bishop)
    function addDirectionalMoves(directions) {
        for (let direction of directions) {
            let newRow = kingRow + direction.row;
            let newCol = kingCol + direction.col;
            while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                const targetSquare = getSquareAt(newRow,newCol);
                
                if (targetSquare.pieceColor === currentPlayer) {
                    break; // Can't move into a square occupied by the same color piece
                }

                // Simulate move and check for validity (ensure king doesn't move into check)
                if (handleMove({ row: kingRow, col: kingCol }, targetSquare, board, currentPlayer)) {
                    possibleMoves.push({ row: newRow, col: newCol });
                }

                // Stop movement if the square has an opponent piece (king can attack, but can't move further)
                if (targetSquare.pieceColor && targetSquare.pieceColor !== currentPlayer) {
                    break;
                }

                // Continue moving in the direction for Rook/Bishop-like moves
                newRow += direction.row;
                newCol += direction.col;
            }
        }
    }

    // Rook-like moves (horizontal/vertical)
    addDirectionalMoves(rookDirections);

    // Bishop-like moves (diagonals)
    addDirectionalMoves(bishopDirections);

    // Knight-like moves
    for (let knightMove of knightMoves) {
        const newRow = kingRow + knightMove.row;
        const newCol = kingCol + knightMove.col;
        
        // Ensure the knight-like move is within the board boundaries
        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
            const targetSquare = board[newRow * 8 + newCol];
            
            // Validate knight-like move
            if (targetSquare.pieceColor !== currentPlayer) {
                if (handleMove({ row: kingRow, col: kingCol }, targetSquare, board, currentPlayer)) {
                    possibleMoves.push({ row: newRow, col: newCol });
                }
            }
        }
    }

    // Return the list of possible moves where king can safely move or attack
    return possibleMoves;
}

function getCastlingMoves(kingRow, kingCol, board, isInCheck) {
    const castlingMoves = [];

    // Kingside castling
    const kingsideRookCol = 7; // Rook on h-file
    const kingsideRookSquare = getSquareAt(kingRow, kingsideRookCol);
    const kingsideRookPiece = kingsideRookSquare.img;

    // Check if rook is available, has not moved, and path is clear
    if ((kingsideRookPiece === 'R' || kingsideRookPiece === 'r') && 
        !kingsideRookSquare.hasMoved && // Check if rook has moved
        !getSquareAt(kingRow, kingCol).hasMoved && // Check if king has moved
        isPathClear(kingRow, kingCol, kingRow, 6) && // Check path from king to g-file
        isKingSafe(kingRow, 5, board) && // Check if f-file is safe
        isKingSafe(kingRow, 6, board)) { // Check if g-file is safe
        castlingMoves.push({ row: kingRow, col: 6 }); // King's move to g-file
    }

    // Queenside castling
    const queensideRookCol = 0; // Rook on a-file
    const queensideRookSquare = getSquareAt(kingRow, queensideRookCol);
    const queensideRookPiece = queensideRookSquare.img;

    // Check if rook is available, has not moved, and path is clear
    if ((queensideRookPiece === 'R' || queensideRookPiece === 'r') && 
        !queensideRookSquare.hasMoved && // Check if rook has moved
        !getSquareAt(kingRow, kingCol).hasMoved && // Check if king has moved
        isPathClear(kingRow, kingCol, 2, 3) && // Check path from king to c-file
        isKingSafe(kingRow, 1, board) && // Check if b-file is safe
        isKingSafe(kingRow, 2, board)) { // Check if c-file is safe
        castlingMoves.push({ row: kingRow, col: 2 }); // King's move to c-file
    }

    return castlingMoves;
}

function notBlocked(kingRow, kingCol, tempBoard, kingColor, possibleMoves) {
    const opponentPieces = ['P', 'Q', 'R', 'N', 'B'];
    
    const directions = [
        { row: -1, col: -1 }, // Top-left
        { row: -1, col: 0 },  // Top
        { row: -1, col: 1 },  // Top-right
        { row: 0, col: -1 },  // Left
        { row: 0, col: 1 },   // Right
        { row: 1, col: -1 },  // Bottom-left
        { row: 1, col: 0 },   // Bottom
        { row: 1, col: 1 }    // Bottom-right
    ];

    // Loop through all directions around the king
    for (let direction of directions) {
        const newRow = kingRow + direction.row;
        const newCol = kingCol + direction.col;

        // Ensure the move is within board boundaries
        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
            const targetSquare = tempBoard[newRow * 8 + newCol];

            // If the square is occupied by an opponent's piece
            if (opponentPieces.includes(targetSquare.img)) {
                // Find and remove this move from the possibleMoves list
                possibleMoves = possibleMoves.filter(move => !(move.row === newRow && move.col === newCol));
            }
        }
    }

    return possibleMoves; // Return the updated possible moves list
}

function getKingPosition(board) {
    let kingPosition = null;

    // Iterate through all squares on the board
    for (let i = 0; i < 64; i++) {
        if (board[i].img === 'K') {
            // If the piece is the white king ('K'), store its position
            kingPosition = { row: Math.floor(i / 8), col: i % 8 };
            break; // Exit the loop once the king is found
        }
    }
    return kingPosition;
}

function handleKingMove(fromRow, fromCol, toRow, toCol, board, isInCheck, piece, targetPiece) {
    allValidMoves = []
    const rowDiff = Math.abs(fromRow - toRow);
    const colDiff = Math.abs(fromCol - toCol);
    // Check if the selected piece is a king
    if (piece !== 'K' && piece !== 'k') {
        //console.log("The selected piece is not a king.");
        return false;
    }

    // Check if it's a valid king move (1 square in any direction)
    if (rowDiff <= 1 && colDiff <= 1) {
        // Create a deep copy of the board to simulate the move
        let tempBoard = board.map(square => ({ ...square })); // Deep copy

        tempBoard[toRow * 8 + toCol] = { 
            img: piece, 
            row: toRow, 
            col: toCol,
            captured: false, 
            promoted: false, 
            element: tempBoard[toRow * 8 + toCol].element,
            hasMoved: true 
        };
        tempBoard[fromRow * 8 + fromCol] = { 
            img: '', 
            row: fromRow, 
            col: fromCol,
            captured: false, 
            promoted: false, 
            element: tempBoard[fromRow * 8 + fromCol].element,
            hasMoved: false
        };
        if (targetPiece && targetPiece.includes(piece === 'K' ? 'k' : 'K')) {
            console.log("King is attempting to capture an opponent's piece.");
        }

        let safeKing = isKingSafe(toRow, toCol, tempBoard);
        if (safeKing) {
            //allValidMoves.push({ row: toRow, col: toCol });
            //console.log("King move (including capture) is valid and safe.", allValidMoves);
            targetPiece = piece;
            piece = '';
            console.log
            return true;
        } else {
            console.log("The king cannot move to or capture on a square that would leave it in check.");
            return false;
        }

    } else if (colDiff === 2 && fromRow === toRow) {
        return handleCastling(fromRow, fromCol, toRow, toCol, board, isInCheck);
    }
    console.log("Invalid king move.");
    return false;
}


// Helper function to calculate index in the flat board array
function getSquareAt(row, col) {
    return board[row * 8 + col];  // Convert 2D coordinates to flat array index
}

function getPieceHasMoved(board) {
    // Loop through all squares on the board to find if any piece has moved
    for (let i = 0; i < board.length; i++) {
        const piece = board[i];
        if (piece.hasMoved) {
            return true; // Return true if any piece has moved
        }
    }
    return false; // Return false if no pieces have moved
}
// Separate function for castling logic
function handleCastling(fromRow, fromCol, toRow, toCol, board, isInCheck) {
    const rookCol = toCol > fromCol ? 7 : 0; // Rook is at H or A column
    const rookPiece = getSquareAt(fromRow, rookCol).img;  // Access the square at (fromRow, rookCol)
    console.log(rookPiece);  // Logs the image string of the rook (if it's there)
    if (rookPiece == 'R' || rookPiece == 'r' && isPathClear(fromRow, fromCol, toRow, toCol)) {
        // Before allowing the castling, check if the destination squares are safe
        const kingPathCols = [fromCol + Math.sign(toCol - fromCol), toCol];
        const isCastlingPathSafe = kingPathCols.every(col => isKingSafe(fromRow, col, board));

        if (isCastlingPathSafe) {
            // Check if it's kingside or queenside castling
            if (rookCol === 7) {  // Kingside castling
                const rookSquare = getSquareAt(fromRow, 7);  // Get the square with the rook (h-file)
                const newRookSquare = getSquareAt(fromRow, 5);  // Target square (f-file)

                // Move the rook from the original square to the new square
                const rookPiece = rookSquare.element.querySelector('img');
                if (rookPiece) {
                    rookSquare.element.removeChild(rookPiece);  // Remove rook from original square
                    newRookSquare.element.appendChild(rookPiece);  // Append rook to new square next to the king
                }
            } else if (rookCol === 0) {  // Queenside castling
                const rookSquare = getSquareAt(fromRow, 0);  // Get the square with the rook (a-file)
                const newRookSquare = getSquareAt(fromRow, 3);  // Target square (d-file)

                // Move the rook from the original square to the new square
                const rookPiece = rookSquare.element.querySelector('img');
                if (rookPiece) {
                    rookSquare.element.removeChild(rookPiece);  // Remove rook from original square
                    newRookSquare.element.appendChild(rookPiece);  // Append rook to new square next to the king
                }
            }

            return true; 
        } else {
            console.log("The king cannot castle through or into a square that is in check.");
            return false;
        }
    }

    console.log("Castling is not allowed.");
    return false;
}

// Helper function to check if the path is clear for Rook, Bishop, and Queen moves
function isPathClearIgnoreKing(fromRow, fromCol, toRow, toCol, board, kingPosition) {
    const rowDirection = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
    const colDirection = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;

    let currentRow = fromRow + rowDirection;
    let currentCol = fromCol + colDirection;

    while (currentRow !== toRow || currentCol !== toCol) {
        // Ignore the king's position on the board when checking for obstructions
        if (currentRow === kingPosition.row && currentCol === kingPosition.col) {
            currentRow += rowDirection;
            currentCol += colDirection;
            continue; // Skip over the king
        }

        const currentSquare = board[currentRow * 8 + currentCol];
        if (currentSquare.img) {
            return false; // Path is blocked
        }
        currentRow += rowDirection;
        currentCol += colDirection;
    }
    return true; // Path is clear
}





// Helper function to check if the path is clear for Rook, Bishop, and Queen moves
function isPathClear(fromRow, fromCol, toRow, toCol) {
    const rowDirection = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
    const colDirection = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;

    let currentRow = fromRow + rowDirection;
    let currentCol = fromCol + colDirection;

    while (currentRow !== toRow || currentCol !== toCol) {
        const currentSquare = board[currentRow * 8 + currentCol];
        if (currentSquare.img) {
            return false; // Path is blocked
        }
        currentRow += rowDirection;
        currentCol += colDirection;
    }
    return true; // Path is clear
}
createBoard();

function movePiece(fromSquare, toSquare) {
    if (fromSquare.img === 'K' && Math.abs(fromSquare.col - toSquare.col) === 2) { // Castling
        // Short castling (King moves to G1)
        if (toSquare.col === 6) {
            // Move the king to G1
            toSquare.img = 'K'; // Place king on the target square
            fromSquare.img = ''; // Clear the original square

            // Move the rook from H1 to F1
            const rookSquare = board[fromSquare.row * 8 + 7]; // H1
            const targetRookSquare = board[fromSquare.row * 8 + 5]; // F1
            targetRookSquare.img = 'R'; // Place rook on the target square
            rookSquare.img = ''; // Clear the original rook square

            // Mark king and rook as having moved
            toSquare.hasMoved = true; // King has moved
            targetRookSquare.hasMoved = true; // Rook has moved
        } 
        // Long castling (King moves to C1)
        else if (toSquare.col === 2) {
            // Move the king to C1
            toSquare.img = 'K'; // Place king on the target square
            fromSquare.img = ''; // Clear the original square

            // Move the rook from A1 to D1
            const rookSquare = board[fromSquare.row * 8 + 0]; // A1
            const targetRookSquare = board[fromSquare.row * 8 + 3]; // D1
            targetRookSquare.img = 'R'; // Place rook on the target square
            rookSquare.img = ''; // Clear the original rook square

            // Mark king and rook as having moved
            toSquare.hasMoved = true; // King has moved
            targetRookSquare.hasMoved = true; // Rook has moved
        }
    } else {
        // Regular piece movement
        toSquare.img = fromSquare.img; // Update the target square's image
        fromSquare.img = ''; // Clear the original square's image

        // Mark the king as having moved if it's a king
        if (toSquare.img) {
            toSquare.hasMoved = true;
        }
    }

    //handleSquareClickForKing(fromSquare)
    toSquare.element.innerHTML = '';
    fromSquare.element.innerHTML = '';

    // Create and append the image element to the target square
    if (toSquare.img) {
        const imgElement = document.createElement('img');
        imgElement.src = chessPieces[toSquare.img]; // Assuming chessPieces is an object mapping piece symbols to image paths
        toSquare.element.appendChild(imgElement);

        // Define the set of lowercase pieces for black
        const blackPieces = ['p', 'b', 'k', 'r', 'q', 'n'];

        // Check if the piece is a black piece (lowercase)
        if (blackPieces.includes(toSquare.img)) {
            toSquare.pieceColor = 'black';
        } else {
            toSquare.pieceColor = 'white';
        }
    }

    //let kingPosition = findKingPosition('white', board)
    //let possibleMoves = getKingPossibleMoves(board, kingPosition.row, kingPosition.col)
    //console.log('All Possible moves without filter for the King:', possibleMoves);
    //console.log('Possible moves for the King:', allValidMovesVar);
    //console.log('Board', board)
    onPieceMove(fromSquare, toSquare, board)
    switchPlayer(); 
}

// Example move event or function
function onPieceMove(fromPosition, toPosition, board) {
    // Check if the king is in check
    const kingPosition = findKingPosition('white', board); // Assuming it's white's turn
    let checker = isKingInCheck(board);
    if (checker) {
        console.log("The king is in check!");

        // Get safe moves for the king
        const safeKingMoves = getSafeKingMoves(kingPosition, board, 'white');

        if (safeKingMoves.length === 0) {
            console.log("Checkmate! No safe moves for the king.");
        } else {
            console.log("Safe moves for the king:", safeKingMoves);
        }
    } else {
        console.log("The king is safe for now.");
    }
}

function getSafeKingMoves(kingPosition, board, currentPlayerColor) {
    let possibleMoves = [];
    let notPossibleMoves = [];
    const directions = [
        { row: -1, col: 0 },  // Up
        { row: 1, col: 0 },   // Down
        { row: 0, col: -1 },  // Left
        { row: 0, col: 1 },   // Right
        { row: -1, col: -1 }, // Up-Left
        { row: -1, col: 1 },  // Up-Right
        { row: 1, col: -1 },  // Down-Left
        { row: 1, col: 1 }    // Down-Right
    ];

    const kingRow = kingPosition.row;
    const kingCol = kingPosition.col;

// Assuming directions is defined and contains the potential moves for the king
    directions.forEach(direction => {
        const newRow = kingRow + direction.row;
        const newCol = kingCol + direction.col;
        // Ensure the move is within board bounds
        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
            const targetSquare = board[newRow * 8 + newCol];

            // Make sure the square is either empty or contains an opponent's piece
            if (!targetSquare.img || targetSquare.pieceColor !== currentPlayerColor) {
                // Create a temporary board
                const tempBoard = createTempBoard(board);
                console.log(tempBoard)
                const originalSquare = tempBoard[kingRow * 8 + kingCol];
                const tempSquare = tempBoard[newRow * 8 + newCol];

                // Store the original state of both squares to restore later
                const originalImg = originalSquare.img;
                const targetImg = tempSquare.img;

                // Move king to new square
                tempSquare.img = originalImg; 

                let underCheck = false;  // Reset underCheck before checking

                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = tempBoard[row * 8 + col];

                        if (piece && piece.pieceColor === 'black' && piece.img !== '') {
                            let piece1 = piece.img.toLowerCase();
                            console.warn(piece1, row, col);
                            console.log("Testing piece:", piece1, "at", { row, col }, "against king at", { row: originalSquare.row, col: originalSquare.col });
                            underCheck = canPieceAttackKing(piece1, { row, col }, { row: originalSquare.row, col: originalSquare.col }, tempBoard);
                            console.log(underCheck);
                            if (underCheck) {
                                possibleMoves.push({ row: newRow, col: newCol });
                                break; // Exit inner loop
                            } else {
                                console.log(notPossibleMoves.push({ row: newRow, col: newCol }));
                            }
                        }
                    }
                    if (underCheck) {
                        break; // Exit outer loop if king is in check
                    }
                }

                // Restore the original state of the squares
                originalSquare.img = originalImg;  // Return king to original square
                tempSquare.img = targetImg;  // Restore the original state of the target square

                // If the king is not under check at the new position, it's a valid move
                if (!underCheck) {
                    console.log("Valid king move:", { row: newRow, col: newCol });
                }
            }
        }
    });

    console.log('Possible Moves', possibleMoves);
    return possibleMoves;
}

// Function to create a deep copy of the board
function createTempBoard(board) {
    return board.map(square => ({
        ...square,
        img: square.img, // Copy the piece image property
        pieceColor: square.pieceColor, // Copy the piece color property
        row: square.row,
        col: square.col
    }));
}

function getAttackingPiecesforKing(board, opponentColor, kingPosition) {
    let attackingPieces = [];
    
    for (let square of board) {
        // Check if the piece belongs to the opponent and is not empty
        if (square.pieceColor === opponentColor && square.img) {
            let allValidMoves = getAllValidMoves(square, board);
            console.log(allValidMoves)
            // Check if any of the valid moves can reach the king's position
            allValidMoves.forEach(move => {
                if (move.row === kingPosition.row && move.col === kingPosition.col) {
                    attackingPieces.push(square.img); // Add attacking piece
                    console.log(`Attacking piece: ${square.img} at position ${square.row}, ${square.col}`);
                }
            });
        }
    }

    return attackingPieces;
}




function promotePawn(square) {
    
}



    // Ensure that FEN is properly generated to reflect the correct side to move
    function generateFen() {
        let fen = '';
        for (let row = 0; row < 8; row++) {
            let emptyCount = 0;
            for (let col = 0; col < 8; col++) {
                const square = board.find(sq => sq.row === row && sq.col === col);
                if (square.img === '') {
                    emptyCount++;
                } else {
                    if (emptyCount > 0) {
                        fen += emptyCount;
                        emptyCount = 0;
                    }
                    fen += square.img;
                }
            }
            if (emptyCount > 0) {
                fen += emptyCount;
            }
            if (row < 7) {
                fen += '/';
            }
        }
        // Indicate it's Black's turn to move ('b')
        fen += ' b KQkq - 0 1'; // Adjust FEN to reflect Black's turn after White's move
        return fen;
    }

    // Send the FEN to the API to fetch the best move for Black
    function sendFenToApi() {
        const fen = generateFen();
        fetch('http://127.0.0.1:5000/get_best_move', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ fen: fen }),
        })
        .then(response => response.json())
        .then(data => {
            if (data.best_move) {
                // Parse the AI move in UCI notation (e.g., e7e5)
                const from = data.best_move.slice(0, 2);
                const to = data.best_move.slice(2, 4);
                const fromRow = 8 - parseInt(from[1]);
                const fromCol = from.charCodeAt(0) - 97;
                const toRow = 8 - parseInt(to[1]);
                const toCol = to.charCodeAt(0) - 97;
                // Calculate the difference in rows and columns

                const fromSquare = board.find(sq => sq.row === fromRow && sq.col === fromCol);
                const toSquare = board.find(sq => sq.row === toRow && sq.col === toCol);
                // Only allow Black pieces to move in the AI response
                if (fromSquare.img && fromSquare.img === fromSquare.img.toLowerCase()) {
                    movePiece(fromSquare, toSquare);
                    console.log(toSquare.img, fromCol , toCol)
                    console.log(toSquare.img, fromRow , toRow)
                    const rowDiff = Math.abs(toRow - fromRow);
                    const colDiff = Math.abs(toCol - fromCol);
                    console.log(colDiff)
                    if ((toSquare.img === 'k') && (colDiff == 2)) {
                        const rookCol = toCol > fromCol ? 7 : 0; // Rook is at H8 or A8
                        const rookSquare = board[fromRow * 8 + rookCol]; // Reference to the rook's square                        
                        const rookTargetCol = toCol > fromCol ? toCol - 1 : toCol + 1; // Position rook next to king
                        movePiece(rookSquare, board[fromRow * 8 + rookTargetCol]);
                    }
                } else {
                    console.error('AI tried to move a White piece. Ignoring.');
                }
            }
        })
        .catch(error => console.error('Error:', error));
        return false;
    }

        // Initialize the board
        // Function to resize the chessboard
function resizeChessboard() {
    // Get the chessboard element by its ID
    const chessboard = document.getElementById("chessboard");

    // Get the maximum width and height of the screen
    const maxWidth = window.innerWidth;
    const maxHeight = window.innerHeight;

    // Calculate the smaller dimension to ensure the chessboard is square
    let boardSize;

    if (maxHeight > maxWidth) {
        boardSize = maxWidth;  // Use max width if the height is larger
    } else {
        boardSize = maxHeight;  // Use max height if the width is larger
    }

    // Set the chessboard's width and height to the calculated size
    chessboard.style.width = boardSize + "px";
    chessboard.style.height = boardSize + "px";
}

// Call the resize function when the page loads
resizeChessboard();

// Add an event listener to resize the chessboard when the window size changes
window.addEventListener('resize', resizeChessboard);

    </script>
</body>
</html>
